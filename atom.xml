<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elliot</title>
  
  
  <link href="https://www.baidu.com/atom.xml" rel="self"/>
  
  <link href="https://www.baidu.com/"/>
  <updated>2020-09-18T08:08:49.810Z</updated>
  <id>https://www.baidu.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>复习杂记四</title>
    <link href="https://www.baidu.com/2020/09/17/%E5%A4%8D%E4%B9%A0%E6%9D%82%E8%AE%B0%E5%9B%9B/"/>
    <id>https://www.baidu.com/2020/09/17/%E5%A4%8D%E4%B9%A0%E6%9D%82%E8%AE%B0%E5%9B%9B/</id>
    <published>2020-09-17T12:43:41.000Z</published>
    <updated>2020-09-18T08:08:49.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><h2 id="1-总线的基本概念"><a href="#1-总线的基本概念" class="headerlink" title="1.总线的基本概念"></a>1.总线的基本概念</h2><p>是一组能为多个部件 <strong>分时</strong> <strong>共享</strong> 的公共传输线路.</p><a id="more"></a><h2 id="2-总线的分类"><a href="#2-总线的分类" class="headerlink" title="2.总线的分类"></a>2.总线的分类</h2><ul><li><p>按数据传输类型</p><blockquote><p>串行总线<br><br>并行总线<br></p></blockquote></li><li><p>按总线功能</p><blockquote><p>(1)片内总线<br><br>(2)系统总线(数据,地址,控制总线)<br><br>单总线<br><br>双总线: 分成主存总线和I/O总线, 由 <strong>通道</strong> 连接<br><br>三总线: 在双总线的基础上, 添加了I/O与内存的通路 <strong>DMA</strong> 总线<br><br>四总线: 添加了 <strong>桥接器</strong>.<br><br>(3)通信总线<br></p></blockquote></li><li><p>按时序控制划分</p><blockquote><p>同步<br><br>异步<br></p></blockquote><h2 id="3-总线的性能指标-nbsp"><a href="#3-总线的性能指标-nbsp" class="headerlink" title="3.总线的性能指标 &nbsp;"></a>3.总线的性能指标 &nbsp;</h2></li><li><p>传输周期(总线周期)</p><blockquote><p>一次总线操作所需的时间<br><br>可以小于 总线时钟周期</p></blockquote></li><li><p>总线时钟周期</p><blockquote><p>即 机器的时钟周期</p></blockquote></li><li><p>时钟频率</p><blockquote><p>时钟周期的倒数</p></blockquote></li><li><p>工作频率</p><blockquote><p>传输周期的倒数</p></blockquote></li><li><p>总线宽度</p><blockquote><p>总线宽<br><br>同时传输数据的位数<br><br>数据总线的根数<br></p></blockquote></li><li><p>总线带宽</p><blockquote><p>数据传输率<br><br>带宽 = 工作频率 x 总线宽度 = 总线宽度/总线周期<br></p></blockquote></li><li><p>串行 并行</p></li><li><p>总线复用</p><h2 id="4-总线仲裁"><a href="#4-总线仲裁" class="headerlink" title="4.总线仲裁"></a>4.总线仲裁</h2><p>&nbsp; &nbsp;解决多个设备争用总线的问题</p></li><li><p>设备分类</p><blockquote><p>主设备: 访问设备<br><br>从设备: 被访问设备<br></p></blockquote></li><li><p>集中仲裁方式(掌握)</p><blockquote><p>主设备发出请求信号<br><br>若多个主设备要使用总线, 则有总线控制器进行仲裁.<br><br>获得总线使用权的主设备开始传送数据.</p></blockquote></li><li><p>链式查询(掌握)</p><blockquote><p>集中式仲裁<br><br>BG,  BR,  BS , 数据线地址线等 与总线控制部件沟通.<br><br>共用一条请求线<br><br>总线忙信号是由获得总线控制权的设备发起的<br></p></blockquote></li><li><p>计数器查询(掌握)</p><blockquote><p>BS , BR(一条) , 设备地址线(一组)<br><br>控制信号由计数器决定<br><br>优先级较为灵活<br><br>线数: log2n + 2<br></p></blockquote></li><li><p>独立请求方式(掌握)</p><blockquote><p>核心  :  排队器<br><br>优先级灵活<br><br>响应快<br><br>线数:2n+1&lt;br]&gt;</p></blockquote></li><li><p>分布仲裁方式</p><blockquote><p>略<br></p></blockquote><h2 id="5-总线操作与定时"><a href="#5-总线操作与定时" class="headerlink" title="5.总线操作与定时"></a>5.总线操作与定时</h2><p>&nbsp; &nbsp; 占用总线的一堆设备, 如何进行数据传输.</p></li><li><p>总线周期四个阶段</p><blockquote><p>(1) 申请分配: 传输请求, 总线仲裁<br><br>(2)寻址阶段: 启动从模块<br><br>(3)传输阶段 : 数据交换<br><br>(4)结束阶段 : 将这次传输的信息从总线上删除<br><br>&nbsp; &nbsp; 总线定时: 实质是规定双方数据交换过程中需要时间上的配合关系的  <strong>协议</strong>.</p></blockquote></li><li><p>同步通信 (统一时钟)</p><blockquote><p>读命令的过程<br><br>速度快 , 逻辑简单<br><br>主从设备强制同步, 不能及时进行有效性检验,可靠性差.</p></blockquote></li><li><p>异步通信 (统一时钟)(<strong>考点</strong>: 数据传输率)</p><blockquote><p>通过握手<br><br>主设备请求, 从设备回答<br><br>1)不互锁<br><br>主从设备不关心对方是收到信号<br><br>2)半互锁<br><br>从设备不关心对方是否收到回答<br><br>3)全互锁<br><br>  主从设备都关心对方<br><br>比同步控制方式慢, 复杂<br></p></blockquote><p>&nbsp; &nbsp; 波特率:  单位时间内传送的二进制位.(详细定义见计网)<br><br>&nbsp; &nbsp;比特率 : 单位时间内传送的有效二进制位<br><br>&nbsp; &nbsp;|起始位|校验位|数据位|停止位|<br></p></li></ul><h2 id="6-总线标准"><a href="#6-总线标准" class="headerlink" title="6.总线标准"></a>6.总线标准</h2><p>即插即用<br><br>热插拔<br><br>重要标准: ISA, EISA ,PCI ,PCI-E,USB<br></p><ul><li><p>系统总线标准</p></li><li><p>设备总线标准</p></li><li><p>局部总线 :在ISA与CPU总线间的管理层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ISA 8MHz 8&#x2F;16 16MB&#x2F;s 系统总线 DMA接口与CPU管理</span><br><span class="line">EISA 8MHz 32 32MB&#x2F;s 系统总线</span><br><span class="line">注: ISA不支持总线仲裁</span><br><span class="line">PCI 33&#x2F;66MHz 32&#x2F;64 528MB&#x2F;s 局部总线</span><br><span class="line">不依附于某个处理器 即插即用 可扩展性好(解决高速外设)</span><br><span class="line">AGP 局部总线(解决更高速的外设) 并行</span><br><span class="line">PCI-E 10GB&#x2F;s以上 串行 双向传输 全双工 热插拔</span><br><span class="line">VESA 33MHz 32 132MB&#x2F;s 局部总线</span><br><span class="line">USB 1280MB&#x2F;s 设备总线 串行</span><br><span class="line">RS-232C 串行通信总线</span><br><span class="line">IDE 硬盘光驱接口</span><br><span class="line">SATA 串行硬盘接口</span><br><span class="line">SCSI 智能通用接口</span><br><span class="line">VGA </span><br><span class="line">DVI</span><br><span class="line">HDMI</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;总线&quot;&gt;&lt;a href=&quot;#总线&quot; class=&quot;headerlink&quot; title=&quot;总线&quot;&gt;&lt;/a&gt;总线&lt;/h1&gt;&lt;h2 id=&quot;1-总线的基本概念&quot;&gt;&lt;a href=&quot;#1-总线的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.总线的基本概念&quot;&gt;&lt;/a&gt;1.总线的基本概念&lt;/h2&gt;&lt;p&gt;是一组能为多个部件 &lt;strong&gt;分时&lt;/strong&gt; &lt;strong&gt;共享&lt;/strong&gt; 的公共传输线路.&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机组成原理" scheme="https://www.baidu.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>复习杂记三</title>
    <link href="https://www.baidu.com/2020/09/16/%E5%A4%8D%E4%B9%A0%E6%9D%82%E8%AE%B0%E4%B8%89/"/>
    <id>https://www.baidu.com/2020/09/16/%E5%A4%8D%E4%B9%A0%E6%9D%82%E8%AE%B0%E4%B8%89/</id>
    <published>2020-09-16T12:20:53.000Z</published>
    <updated>2020-09-17T12:41:01.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h1><h2 id="1-进程调度时机与方法"><a href="#1-进程调度时机与方法" class="headerlink" title="1.进程调度时机与方法"></a>1.进程调度时机与方法</h2><a id="more"></a><p>进程调度 : 按某些算法从就绪队列选择一个进程给处理机.</p><ul><li>时机<blockquote></blockquote>  进程主动放弃 <strong>非剥夺</strong><br>  被动放弃  <strong>剥夺</strong><br>  处理中断时  ,  拒绝进程调度<br>  进程在内核临界区时  ,  拒绝调度  (注意区分 <strong>内核临界区</strong> 与 <strong>临界区</strong> )<br>  原语操作时  ,  拒绝调度<br>  临界资源 : 一段时间内只允许一个进程使用的资源.<br>  临界区 : 访问临界资源的代码 eg <strong>访问打印机的进程</strong><br>  内核程序临界区 : <strong>进程的就绪队列</strong> (由就绪进程与PCB组成)<blockquote></blockquote></li><li>方式<blockquote><p>非剥夺 (早期批处理系统)<br>  非剥夺 (分时操作系统, 实时操作系统)<br></p></blockquote></li><li>切换与过程<blockquote><p>狭义定义<br><br>  广义定义<br><br>  对旧进程数据的保存<br><br>  对新进程数据的恢复<br><br>  进程切换不可过于频繁<br></p></blockquote></li></ul><h2 id="2-调度算法评价"><a href="#2-调度算法评价" class="headerlink" title="2.调度算法评价"></a>2.调度算法评价</h2><ul><li>CPU利用率<blockquote><p>可推广为设备利用率<br><br>  甘特图</p></blockquote></li><li>系统吞吐量<blockquote><p>作业/时间</p></blockquote></li><li>周转时间<blockquote><p>作业完成时间-作业提交时间<br><br>  平均周转时间(算数平均)<br><br>  带权周转时间: 时间/时间运行时间<br></p></blockquote></li><li>等待时间<blockquote><p>外存-&gt;内存-&gt;被服务<br><br>  进程的等待时间<br><br>  作业的等待时间<br></p></blockquote></li><li>响应时间<blockquote><p>用户提交到被响应的时间<br></p></blockquote></li></ul><h2 id="3-调度算法"><a href="#3-调度算法" class="headerlink" title="3.调度算法"></a>3.调度算法</h2><ul><li><p>时间片轮转</p><blockquote><p>为进程<br><br>公平<br><br>抢占式<br><br>分时操作系统更看重响应时间<br><br>要是换进程的开销不超过1% <br><br>对每个进程公平<br><br>高频切换有开销<br><br>不会导致饥饿<br><br>无优先级<br></p></blockquote></li><li><p>优先级调度</p><blockquote><p>作业/进程/IO调度<br><br>可抢占  ,  可不抢占<br><br>优先数<br><br>优先级<br><br>就绪队列按照优先级动态改变<br><br>静态优先级/动态优先级<br><br>系统进程一般高于用户进程<br><br>前台进程一般高于后台进程<br><br>操作系统更偏好I/O繁忙型进程<br><br>在就绪队列等待了较长时间,提高优先级<br><br>在处理机运行时间很长,可降低优先级<br><br>频繁调用I/O,可提高优先级<br><br>可能导致低优先级进程饥饿<br></p></blockquote></li><li><p>SIF </p><blockquote></blockquote></li><li><p>多级反馈队列</p><blockquote><p>其他算法的折衷<br><br>(1)设置多级就绪队列, 优先级高到低, 时间片小到大.<br><br>(2)新进程进入第一级队列,按FCFS分配时间片.<br><br>(3)时间片用完 , 进程还未结束. 进入下一级队尾. 如若在最下级, 则调回队尾.<br><br>(4)只有k级队列空, k+1才会被分配时间片.<br><br>若运行时更高级队列不空, 则该进程被剥夺, 调入所在队列队尾<br></p></blockquote><h2 id="3-进程互斥的硬件实现方法"><a href="#3-进程互斥的硬件实现方法" class="headerlink" title="3.进程互斥的硬件实现方法"></a>3.进程互斥的硬件实现方法</h2></li><li><p>中断屏蔽</p><blockquote><p>在访问临界区前关闭中断<br><br>不适用于多处理机的机器<br><br>只适用于内核进程(才有权限)<br></p></blockquote></li><li><p>TSL指令</p><blockquote><p>硬件实现  ,  执行时无法中断<br></p></blockquote></li><li><p>Swap指令</p><blockquote><p>多处理机环境</p></blockquote></li></ul><h2 id="4-进程互斥的软件实现方法"><a href="#4-进程互斥的软件实现方法" class="headerlink" title="4.进程互斥的软件实现方法"></a>4.进程互斥的软件实现方法</h2><p>一个进程互斥的场景</p><pre><code>进程A:&#123;    其他代码;    使用打印机;    其他代码;&#125;进程B:&#123;    其他代码;    使用打印机;    其他代码;&#125;//先A在处理机上运行当A使用打印机时,  A时间片用完,  B获取处理机然后使用打印机.后果: A, B打印内容混了.解决方法: 互斥使用临界区资源</code></pre><ul><li><p>单标志法</p><blockquote><p>每个进程进入临界区的权限只能被另一进程赋予<br><br>谦让<br><br>违背 <strong>空闲让进</strong> 原则<br></p></blockquote></li><li><p>双标志先检查</p><blockquote><p>设置flag[]标记各进程想要进入临界区的意愿<br><br>(1)老渣是否想用( <strong>检查意愿</strong> )<br><br>(2)我小渣要用( <strong>上锁</strong> )<br><br>(3)用马桶( <strong>访问临界区</strong>)<br><br>(4)用完了( <strong>解锁</strong> )<br><br>在并发环境下(1)(2)被中断<br><br>违反忙则等待(检查后,来不及上锁)</p></blockquote></li><li><p>双标志后检查 </p><blockquote><p>与先检查不同的是: 先上锁,  后检查.<br><br>违背空闲让进,  有限等待<br><br>导致饥饿<br></p></blockquote></li><li><p>Peterson算法</p><blockquote><p>flag[]表达意愿<br><br>turn 表达谦让<br><br>(1)我表达意愿 flag = true<br><br>(2)谦让       turn = other<br><br>(3)若你想用,我等待<br><br>(4)访问临界区<br><br>(5)取消意愿<br><br>最后表达谦让的,  将失去主动权<br><br>实现了<br><br>(1)空闲让进<br><br>(2)忙则等待<br><br>(3)有限等待<br><br>未实现<br><br>(1)让权等待<br></p></blockquote></li></ul><h2 id="5-信号量机制"><a href="#5-信号量机制" class="headerlink" title="5.信号量机制"></a>5.信号量机制</h2><p>双标志检查法的缺陷在于 : 检查,  上锁无法一起喝成<br><br>所有解决方案无法实现让权等待<br><br>dijstra提出信号量机制实现进程操作与同步<br><br>用户进程可使用一对 <strong>原语</strong> 来对 <strong>信号量</strong> 操作 <br><br>信号量 : 表示操作系统某些资源的变量.<br><br>一对原语: <strong>wait(s)</strong> (<strong>P操作</strong>),<br><strong>signal(s)</strong> (<strong>V操作</strong>).</p><ul><li>整型信号量 (探讨缺陷)<blockquote><p>(1)初始化<br><br>(2)P操作(进入区)<br><br>(3)V操作(退出区)<br><br>会发生忙等<br></p></blockquote>P,V代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( S&lt;= <span class="number">0</span> ); <span class="comment">//?既然不可中断</span></span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">( <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>记录型信号量(<strong>高频考点</strong>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125;semaphore;</span><br><span class="line"><span class="comment">/*进程需要使用资源, 通过wait原语申请*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        block (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完后*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>P0进程<br><br>…<br><br>wait(s);<br><br>使用打印机…<br><br>signal(s);<br><br>…<br><br>实现让权等待(等不到资源,  就放弃cpu控制权)(避免忙等)<br></p></blockquote></li></ul><blockquote></blockquote><h2 id="6-信号量机制实现-同步-互斥-前驱"><a href="#6-信号量机制实现-同步-互斥-前驱" class="headerlink" title="6.信号量机制实现 同步 互斥 前驱"></a>6.信号量机制实现 同步 互斥 前驱</h2><ul><li><p>进程互斥</p><blockquote><p>(1) 划定临界区<br><br>  (2)设置 <strong>互斥信号量</strong> (进入临界区的名额) <strong>mutex</strong> 初值为1.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//记录型信号量 </span></span><br><span class="line">P1()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex);    <span class="comment">//与V成对</span></span><br><span class="line">    临界区代码...</span><br><span class="line">    V(mutex);   <span class="comment">//与P成对</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>进程同步:</strong> 要让并发进程有序推进.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//代码4必须在代码2后</span></span><br><span class="line">    semaphore S=<span class="number">0</span>    </span><br><span class="line">    P1()&#123;</span><br><span class="line">        代码<span class="number">1</span></span><br><span class="line">        代码<span class="number">2</span></span><br><span class="line">        V(S)</span><br><span class="line">        代码<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    P2()&#123;</span><br><span class="line">        P(S)</span><br><span class="line">        代码<span class="number">4</span></span><br><span class="line">        代码<span class="number">5</span></span><br><span class="line">        代码<span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    ``` </span><br><span class="line">   &gt;(<span class="number">1</span>)在前操作后执行V(S)&lt;br&gt;</span><br><span class="line">   &gt;(<span class="number">2</span>)在后操作前执行P(S)&lt;br&gt;</span><br><span class="line"></span><br><span class="line">* 实现前驱</span><br><span class="line">    &gt;多级进程同步&lt;br&gt;</span><br><span class="line">    &gt;    </span><br><span class="line"></span><br><span class="line">## <span class="number">7.</span>生产者消费者问题</span><br><span class="line">* 问题描述</span><br><span class="line">    &gt;(<span class="number">1</span>)一组生产者&lt;br&gt;</span><br><span class="line">    (<span class="number">2</span>)一组消费者&lt;br&gt;</span><br><span class="line">    (<span class="number">3</span>)一定大小的缓冲区&lt;br&gt;</span><br><span class="line">    (<span class="number">4</span>)缓冲区没满时生产者才能生产&lt;br&gt;</span><br><span class="line">    (<span class="number">5</span>)缓冲区不空消费者才能取&lt;br&gt;</span><br><span class="line">    (<span class="number">6</span>)必须互斥访问缓冲区 __临界资源__ &lt;br&gt;</span><br><span class="line">    &gt;</span><br><span class="line">* 问题分析</span><br><span class="line">    &gt;(<span class="number">1</span>)找出 __同步__ __互斥__ 关系&lt;br&gt;</span><br><span class="line">    &gt;(<span class="number">2</span>)确定 P V大致顺序&lt;br&gt;</span><br><span class="line">    &gt;(<span class="number">3</span>) 消费者,生产者与有产品,缓冲区没满为同步关系&lt;br&gt;</span><br><span class="line">    (<span class="number">4</span>) 各进程互斥&lt;br&gt;</span><br><span class="line">* 代码实现</span><br><span class="line">    ```c</span><br><span class="line">    semaphore mutex = <span class="number">1</span>;</span><br><span class="line">    semaphore empty = n;</span><br><span class="line">    semaphore full = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生产者代码</span></span><br><span class="line">    producer ()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            生产一个产品;</span><br><span class="line">            P(empty);</span><br><span class="line">            P(mutex);</span><br><span class="line">            把产品放入缓冲区;</span><br><span class="line">            V(mutex);</span><br><span class="line">            V(full);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    consumer ()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            P(full);</span><br><span class="line">            P(mutex);</span><br><span class="line">            从缓冲区取产品;</span><br><span class="line">            V(mutex);</span><br><span class="line">            V(empty);</span><br><span class="line">            使用产品;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费者代码</span></span><br><span class="line">    <span class="comment">//</span></span><br></pre></td></tr></table></figure><blockquote><p>如若交换某些P操作, 可能发生死锁<br><br>交换V操作问题不大<br><br>不要把取与用操作放在一起, 慧染加锁过程消耗的时间变长<br></p></blockquote></li></ul><h2 id="8-多生产多消费"><a href="#8-多生产多消费" class="headerlink" title="8.多生产多消费"></a>8.多生产多消费</h2><ul><li><p>问题描述</p><blockquote><p>(1)生产者生产不同产品<br><br>(2)消费者消费不同产品<br><br>(3)一个缓冲区</p></blockquote></li><li><p>问题分析</p><blockquote><p>(1)互斥关系<br><br>(2)同步关系<br></p></blockquote></li><li><p>代码实现</p><blockquote><p>略</p></blockquote></li><li><p><strong>注意</strong> </p><blockquote><p>生产者消费者问题中, 若缓冲区大于1, 则必须设置mutex实现互斥访问.</p></blockquote></li></ul><h2 id="9-吸烟者问题"><a href="#9-吸烟者问题" class="headerlink" title="9.吸烟者问题"></a>9.吸烟者问题</h2><ul><li><p>问题描述</p><blockquote><p>(1)一个生产者供应三种组合<br><br>(2)三个吸烟者进程, 需要特定的一种组合才能抽烟<br><br>(3)缓冲区大小为1<br><br>(4)让消费者轮流吸烟<br><br>(5)消费者消费完才能进行下一次生产</p></blockquote></li><li><p>问题分析<br>略</p></li><li><p>代码实现</p></li><li><p>注意 </p><blockquote><p>这个问题可以为我们们解决 <strong>就可以生产多个产品的单生产者问题</strong> 提供解决思路.</p></blockquote></li></ul><h2 id="10-读者写者问题"><a href="#10-读者写者问题" class="headerlink" title="10.读者写者问题"></a>10.读者写者问题</h2><ul><li><p>问题描述</p><blockquote><p>(1)允许多个读者读文件<br></p><pre><code>(2)允许一个写者写&lt;br&gt;(3)在写操作完成前, 不允许其他读者与写者工作&lt;br&gt;(4)写操作开始前, 所有进程需退出文件 &lt;br&gt;(5)操作系统中对共享文件的操作&lt;br&gt;(6)文件由缓存段构成&lt;br&gt;</code></pre></blockquote></li><li><p>问题分析</p><blockquote><p>(1)两类进程: 写进程, 读进程<br><br>  (2)两类互斥关系: 写-写, 读-写<br><br>  (3)第一个读进程加锁,最后一个读进程解锁(可能读进程 <strong>死锁</strong> ,写进程 <strong>饿死</strong>).<br><br>  (4) 加入count 解决 <strong>读进程死锁</strong> , 加入w实现写优先 解决 <strong>写进程饿死</strong></p></blockquote></li><li><p>代码实现</p><blockquote><p>略<br></p></blockquote></li><li><p>核心思想 </p><blockquote><p>设置计算器count<br><br>  如果操作不能一气喝成,则需要对操作加锁<br></p></blockquote><h2 id="11-哲学家进餐"><a href="#11-哲学家进餐" class="headerlink" title="11.哲学家进餐"></a>11.哲学家进餐</h2></li><li><p>问题描述</p><blockquote><p>(1)五个哲学家,有思考与进食两个状态.<br><br>  (2)只有5根筷子<br><br>  (3)哲学家只能拿到自己左手右手边的筷子才能进食.<br><br>  (4)进食完, 放下筷子<br></p></blockquote></li><li><p>问题分析</p><blockquote><p>(1)必须持有两个临界资源才能进食<br><br>(2)合理分配临界资源, 防止 <strong>死锁</strong> .<br><br>(3)定义互斥信号量数组chopstick[5], 对五个筷子实现互斥使用.<br> (4) 最多允许四个哲学家进食 <strong>防止死锁方案一</strong><br><br> (5) 奇数号哲学家先拿左边筷子, 偶数号先拿右边的 <strong>防止死锁方案二</strong><br><br> (6) 仅当哲学家能拿两个筷子时才能拿筷子(需配合互斥信号量实现一气呵成) <strong>防止死锁方案三</strong><br></p></blockquote></li><li><p>代码实现</p><blockquote><p>略</p></blockquote><h2 id="12-管程"><a href="#12-管程" class="headerlink" title="12.管程"></a>12.管程</h2><p>因为信号量机制存在编程困难和容易出错的确定, 需要引入管程.<br><br>让程序员从信号量中解放<br><br>一种高级进程管理技术<br></p></li><li><p>定义</p><blockquote><p>(1) 局部于管程的 共享数据结构 说明.<br><br>  (2)对 共享数据结构 的操作的过程<br><br>  (3)对共享数据进行 初始化 的语句<br><br>  (4)得有一个名字<br><br>  (5)管程数据只能有局部的过程才能访问数据<br><br>  (6)每次仅允许一个进程在管程内执行某个内部过程<br><br>  (7)每次只允许一个进程访问管程<br></p></blockquote></li><li><p>编码示例</p><blockquote><p>略</p></blockquote><h2 id="12-死锁的概念"><a href="#12-死锁的概念" class="headerlink" title="12.死锁的概念"></a>12.死锁的概念</h2></li><li><p>死锁</p></li><li><p>饥饿</p></li><li><p>死循环</p><h2 id="13-死锁的预防"><a href="#13-死锁的预防" class="headerlink" title="13.死锁的预防"></a>13.死锁的预防</h2></li><li><p>破坏互斥条件</p><blockquote><p>将互斥的资源, 转换成共享设备(SPOOLing技术)<br></p></blockquote></li><li><p>破坏不剥夺条件</p><blockquote></blockquote><p>  当一个进程请求资源不得到满足时, 他必须释放它拥有的所有资源<br><br>  当一个进程请求资源不得到满足时, 强行剥夺他人资源<br><br>  实现复杂<br><br>  前功尽弃, 只适用于易保存, 易恢复, 如CPU<br><br>  容易造成饥饿<br></p><blockquote></blockquote></li><li><p>破坏请求和保持</p><blockquote><p>静态分配方法<br><br>资源利用率低<br><br>导致进程饥饿<br></p></blockquote></li><li><p>破坏循环等待条件</p><blockquote><p>给资源编号<br><br> 进程必须按编号递增的顺序请求资源<br><br> 同类资源一次性申请完<br><br> 添加新设备不方便<br><br> 实际顺序与编号顺序不一致<br><br> 必须按规定次序申请,  编程麻烦<br></p></blockquote><h2 id="13-避免死锁-小题-大题"><a href="#13-避免死锁-小题-大题" class="headerlink" title="13.避免死锁 (小题, 大题)"></a>13.避免死锁 (小题, 大题)</h2></li><li><p>银行家算法</p><blockquote><p>找到安全序列<br><br>安全状态, 不会发生死锁<br><br>不安全状态, 可能发生死锁<br><br>钱 -&gt; 各种资源, 即数字 -&gt; 向量<br><br>进程编号 -&gt; 最大需求 -&gt; 已分配 -&gt; 最多还需要<br><br>考试要求 : 找出安全序列<br></p></blockquote></li></ul><h2 id="14-死锁的检测与解除"><a href="#14-死锁的检测与解除" class="headerlink" title="14.死锁的检测与解除"></a>14.死锁的检测与解除</h2><ul><li><p>检测</p><blockquote><p>数据结构: 资源分配图(进程节点,  和资源节点)<br><br>能消除图所以边, 则处于安全状态, 一定不发生死锁.<br><br>不能消除, 则已经发生死锁<br></p></blockquote></li><li><p>解除</p><blockquote><p>(1)资源剥夺法<br><br>(2)撤销进程法<br><br>(3)进程回退法<br><br>进程优先级<br><br>执行时间<br><br>持有进程种类<br><br>完成时间<br><br>交互式与批处理式的<br></p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;处理机管理&quot;&gt;&lt;a href=&quot;#处理机管理&quot; class=&quot;headerlink&quot; title=&quot;处理机管理&quot;&gt;&lt;/a&gt;处理机管理&lt;/h1&gt;&lt;h2 id=&quot;1-进程调度时机与方法&quot;&gt;&lt;a href=&quot;#1-进程调度时机与方法&quot; class=&quot;headerlink&quot; title=&quot;1.进程调度时机与方法&quot;&gt;&lt;/a&gt;1.进程调度时机与方法&lt;/h2&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="https://www.baidu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>复习杂记二</title>
    <link href="https://www.baidu.com/2020/09/16/%E5%A4%8D%E4%B9%A0%E6%9D%82%E8%AE%B02/"/>
    <id>https://www.baidu.com/2020/09/16/%E5%A4%8D%E4%B9%A0%E6%9D%82%E8%AE%B02/</id>
    <published>2020-09-16T07:14:49.518Z</published>
    <updated>2020-09-16T12:23:31.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h1><h2 id="1-进程与程序"><a href="#1-进程与程序" class="headerlink" title="1.进程与程序"></a>1.进程与程序</h2><a id="more"></a><blockquote><p>进程：动态。身份：PID。实体：PCB。<br>程序：静态<br>linux：task struct（PCB）<br>source code -&gt; exe（指令序列）-&gt;载入内存，建立PCB，数据段<br>进程实体，进程映像（日常讨论的进程）eg. 进程调度<br>进程 ：获得资源的基本单位</p></blockquote><h2 id="2-进程状态的转换"><a href="#2-进程状态的转换" class="headerlink" title="2.进程状态的转换"></a>2.进程状态的转换</h2><blockquote><p>创建态–(分配志愿)–&gt;就绪态–(处理机到达)–&gt;运行态<br>运行态–(等待某个资源)–&gt;阻塞态<br>阻塞态–(资源到达)–&gt;就绪态<br>运行态–(exit)–&gt;中止态<br>运行态–(致命错误)–&gt;终止态<br>运行态–(时钟中断)–&gt;中止态<br>单核cpu只有一个cpu处于运行态<br>多核cpu可以多个进程同时处于运行态</p></blockquote><h2 id="3-进程的组织"><a href="#3-进程的组织" class="headerlink" title="3.进程的组织"></a>3.进程的组织</h2><ul><li><p>链式方式</p><blockquote><p>执行指针<br>  就绪队列指针<br>阻塞对列指针队列（可分为多个）</p></blockquote></li><li><p>索引方式</p></li></ul><h2 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4.进程控制"></a>4.进程控制</h2><p>实现进程状态的转换 (via.原语(中间不可中断))</p><blockquote><p>( 1 ) PCB变量改变<br>( 2 ) 改变队列 </p></blockquote><p>如若不能一气呵成，则可能损坏进程数据结构。<br>原语: 利用关中断，和开中断这两个 <strong>特权指令</strong>  来实现。</p><ul><li>创建原语<blockquote><p>用户登录<br>作业调度(外存里的程序)<br>提供服务<br> 应用请求</p></blockquote></li><li>撤销原语<blockquote><p>正常结束<br>   异常结束<br>   外界干预</p></blockquote></li><li>阻塞原语<blockquote><p>等待系统分配资源<br>等待合作进程完成工作</p></blockquote></li><li>唤醒原语<blockquote><p>等待的事情发生</p></blockquote></li><li>切换原语<blockquote><p>当前时间片到<br>  更高优先级级程序到<br>  当前程序主动阻塞<br>  进程终止</p></blockquote>进程运行现场<blockquote><p>处理机寄存器 : PSW , PC , IR etc.<br>在进程下处理机时 ,  将 <strong>必要寄存器信息</strong> 即 <strong>上下文</strong> 存入PCB(即保护现场)</p></blockquote></li></ul><h2 id="5-进程通信"><a href="#5-进程通信" class="headerlink" title="5.进程通信"></a>5.进程通信</h2><p>what : 进程间的信息交换( 不同进程内存位置的信息交换 )  </p><ul><li>共享存储<blockquote><p>互斥访问 PV操作<br>  基于数据结构共享<br>  基于存储区的共享</p></blockquote></li><li>管道通信 <blockquote><p>半双工通信<br> 在内存大小固定的缓冲区,  通常为页面大小<br> 要双向同时通信  ,  需要两管道<br> 必须写满才能读<br> 必须读完才能写<br> 读完数据将会被抛弃  ,  所以读进程至多一个</p></blockquote></li><li>消息传递<blockquote><p>格式化消息<br>   进程有消息缓冲队列<br>   网络中的报文<br>   操作系统为进程提供 发送消息/接收消息<br>   直接通信<br>   间接通信 (邮件)</p></blockquote><h2 id="6-线程的特点与概念"><a href="#6-线程的特点与概念" class="headerlink" title="6.线程的特点与概念"></a>6.线程的特点与概念</h2>为什么引入进程?<br>例如QQ的几个功能分成几个进程  ,  那么这几个进程  ,  要共享资源   ,  而且切换进程开销大  ( 更换块表,更换缓存 )  .<br>为了解决上述问题  ,  引入线程.</li></ul><blockquote><p>线程们可共享使用进程资源.<br>切换更加轻量化.<br>进程通信必须要有操作系统介入  ,  开销巨大.<br>多核CPU环境下  ,  各线程分派到不同CPU下工作.<br>线程资源 TCB  ,  寄存器信息  ,  堆栈信息</p></blockquote><h2 id="7-多线程模型"><a href="#7-多线程模型" class="headerlink" title="7.多线程模型"></a>7.多线程模型</h2><ul><li><p>用户级线程(UTL)</p><blockquote><p>线程库(while与if实现)<br>  代码逻辑的载体<br>  此时操作系统只看得见进程  ,  此时是个逻辑线程.<br>  线程由线程库管理<br>  线程库不需要切换用户态<br>  线程并发度不高</p></blockquote></li><li><p>内核级线程(操作系统层面的线程)</p><blockquote><p>操作系统管理线程工作<br>  运行分配的载体<br>  线程切换需要处理机变态<br>  线程成为调度的基本单位<br>  线程管理成本变高</p></blockquote></li><li><p>组合方式</p><blockquote><p>用户级线程 : 内核级线程<br>  1  :  1  管理成本高<br>  n  :  1  并发度低  ,  管理成本低<br>  1  :  n  并发度搞  ,  管理成本较高</p></blockquote><blockquote></blockquote><h2 id="8-处理机调度"><a href="#8-处理机调度" class="headerlink" title="8.处理机调度"></a>8.处理机调度</h2><p>调度的基本概念 : 银行服务客户 , 厕所使用分配<br>处理机调度 : 处理机服务进程  </p></li><li><p>高级调度(作业调度)</p><blockquote><p>外存与内存之间的调度<br>  外存后备队列<br>  无-&gt;创建态-&gt;就绪态</p></blockquote></li><li><p>中级调度</p><blockquote><p>前提 : 虚拟化技术<br>  暂时不能运行的进程调入外存  ,  然后中级调度重新调入内存<br>  调入外存的成为挂起状态<br>  PCB不会被调入外存<br>  就绪挂起  ,  阻塞挂起<br>  五状态-&gt;七状态<br>  挂起态-&gt;就绪态</p></blockquote></li><li><p>低级调度</p><blockquote><p>处理机服务就绪进程<br>  频度高 几毫秒一次<br>  最基本  </p></blockquote><blockquote></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;处理机管理&quot;&gt;&lt;a href=&quot;#处理机管理&quot; class=&quot;headerlink&quot; title=&quot;处理机管理&quot;&gt;&lt;/a&gt;处理机管理&lt;/h1&gt;&lt;h2 id=&quot;1-进程与程序&quot;&gt;&lt;a href=&quot;#1-进程与程序&quot; class=&quot;headerlink&quot; title=&quot;1.进程与程序&quot;&gt;&lt;/a&gt;1.进程与程序&lt;/h2&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="https://www.baidu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>复习杂记一</title>
    <link href="https://www.baidu.com/2020/09/16/%E5%A4%8D%E4%B9%A0%E6%9D%82%E8%AE%B0/"/>
    <id>https://www.baidu.com/2020/09/16/%E5%A4%8D%E4%B9%A0%E6%9D%82%E8%AE%B0/</id>
    <published>2020-09-16T06:14:50.000Z</published>
    <updated>2020-09-16T12:17:03.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><a id="more"></a><ul><li>内核程序&amp;应用程序<blockquote><p>内核程序构成内核<br>  一个操作系统只要内核就够了（docker）<br>可执行特权指令（操作系统管理者内核执行）</p></blockquote></li><li>内核态（目态）&amp;用户态（管态）<blockquote><p>cpu现在运行什么程序就是什么态<br>psw 0用户，1内核态</p></blockquote></li><li>内核态与用户态的转换<blockquote><p>执行修改psw标志位的指令<br>中断 用户-&gt;内核 操作系统的夺回特权</p></blockquote></li><li>中断与异常<blockquote><p>中断是操作系统内核夺回控制权的唯一途径<br>   无中断，做不到并发<br>   内中断： 恶意软件试图在用户态执行特权指令。指令参数非  法。陷入指令（非特权指令）。  故障。<br>   外中断 ：时钟中断（多道的基础）。I/O中断。<br>   根据中断信号的不同，有相应的中断处理程序（内核程序）。中断向量表。</p></blockquote><ul><li>系统调用<blockquote><p>应用程序程序员请求操作系统服务的途径<br>库函数使用了系统调用<br>系统调用比库函数底层<br>库函数暴露接口，不一定使用了系统调用<br>系统对共享资源统一管理，而应用程序只能发起系统调用来使用。eg. 访问任何共享资源，都要系统调用。<br>trap指令，访管指令</p></blockquote></li></ul></li><li>操作系统体系结构<blockquote><p>1.时钟管理。中断处理。原语<br>  2.进程管理。存储器管理。设备管理。（可以踢出内核）<br>  微内核 2 六次变态<br>  大内核 1,2 两次变态</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;操作系统概述&quot;&gt;&lt;a href=&quot;#操作系统概述&quot; class=&quot;headerlink&quot; title=&quot;操作系统概述&quot;&gt;&lt;/a&gt;操作系统概述&lt;/h1&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="https://www.baidu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>下论文</title>
    <link href="https://www.baidu.com/2020/09/14/%E4%B8%8B%E8%AE%BA%E6%96%87/"/>
    <id>https://www.baidu.com/2020/09/14/%E4%B8%8B%E8%AE%BA%E6%96%87/</id>
    <published>2020-09-14T04:43:20.000Z</published>
    <updated>2020-09-14T04:46:12.557Z</updated>
    
    <content type="html"><![CDATA[<p>下好了POPL和PLDI的往届论文，准备没事看看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下好了POPL和PLDI的往届论文，准备没事看看。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://www.baidu.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>无聊</title>
    <link href="https://www.baidu.com/2020/09/11/%E6%97%A0%E8%81%8A/"/>
    <id>https://www.baidu.com/2020/09/11/%E6%97%A0%E8%81%8A/</id>
    <published>2020-09-11T13:07:25.000Z</published>
    <updated>2020-09-11T13:08:29.443Z</updated>
    
    <content type="html"><![CDATA[<p>线性代数越学越多（头秃</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线性代数越学越多（头秃&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://www.baidu.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>meow meow meow</title>
    <link href="https://www.baidu.com/2020/09/06/meow-meow-meow/"/>
    <id>https://www.baidu.com/2020/09/06/meow-meow-meow/</id>
    <published>2020-09-06T15:09:25.000Z</published>
    <updated>2020-09-07T15:10:43.111Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
